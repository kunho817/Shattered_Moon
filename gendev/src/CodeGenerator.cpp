/**
 * @file CodeGenerator.cpp
 * @brief Implementation of code generation utilities
 */

#include "CodeGenerator.h"
#include "CLI.h"

#include <fstream>
#include <sstream>
#include <algorithm>
#include <regex>

namespace gendev
{
    // ============================================================================
    // Default Templates (fallback when template files not found)
    // ============================================================================

    static const char* DEFAULT_COMPONENT_TEMPLATE = R"(// ${FILE_PATH}
#pragma once

namespace SM
{
    /**
     * @brief ${NAME} component
     *
     * Generated by gendev tool.
     */
    struct ${NAME}Component
    {
${MEMBERS}

        ${NAME}Component() = default;
${CONSTRUCTOR}
    };

} // namespace SM
)";

    static const char* DEFAULT_SYSTEM_H_TEMPLATE = R"(// ${FILE_PATH}
#pragma once

/**
 * @file ${NAME}System.h
 * @brief ${NAME} system for Shattered Moon ECS
 *
 * Generated by gendev tool.
 */

#include "../System.h"

namespace SM
{
    // Forward declaration
    class World;

    /**
     * @brief ${NAME} system
     *
     * TODO: Add system description.
     */
    class ${NAME}System : public System<${NAME}System>
    {
    public:
        ${NAME}System();
        ~${NAME}System();

        const char* GetName() const override { return "${NAME}System"; }
        void Update(World& world, float deltaTime) override;
    };

} // namespace SM
)";

    static const char* DEFAULT_SYSTEM_CPP_TEMPLATE = R"(#include "${NAME}System.h"
#include "../World.h"

namespace SM
{
    ${NAME}System::${NAME}System()
    {
    }

    ${NAME}System::~${NAME}System()
    {
    }

    void ${NAME}System::Update(World& world, float deltaTime)
    {
        (void)world;
        (void)deltaTime;

        // TODO: Implement system logic
        // Example:
        // for (EntityID entity : m_Entities)
        // {
        //     auto& component = world.GetComponent<SomeComponent>(entity);
        //     // Process component...
        // }
    }

} // namespace SM
)";

    static const char* DEFAULT_EVENT_TEMPLATE = R"(// ${FILE_PATH}
#pragma once

namespace SM
{
    /**
     * @brief ${NAME} event
     *
     * Generated by gendev tool.
     */
    struct ${NAME}Event
    {
${MEMBERS}

        ${NAME}Event() = default;
${CONSTRUCTOR}
    };

} // namespace SM
)";

    // ============================================================================
    // Helper Functions
    // ============================================================================

    std::vector<MemberDefinition> ParseMemberDefinitions(const std::vector<std::string>& args)
    {
        std::vector<MemberDefinition> members;

        for (const auto& arg : args)
        {
            // Find the colon separator
            size_t colonPos = arg.find(':');
            if (colonPos != std::string::npos && colonPos > 0 && colonPos < arg.length() - 1)
            {
                std::string name = arg.substr(0, colonPos);
                std::string type = arg.substr(colonPos + 1);

                members.emplace_back(name, type);
            }
        }

        return members;
    }

    // ============================================================================
    // CodeGenerator Implementation
    // ============================================================================

    CodeGenerator::CodeGenerator(const std::string& templatesPath)
        : m_TemplatesPath(templatesPath)
    {
    }

    std::string CodeGenerator::LoadTemplate(const std::string& templateName)
    {
        if (m_TemplatesPath.empty())
        {
            return GetDefaultTemplate(templateName);
        }

        std::filesystem::path templatePath = std::filesystem::path(m_TemplatesPath) / templateName;

        std::ifstream file(templatePath);
        if (!file.is_open())
        {
            // Fallback to default template
            return GetDefaultTemplate(templateName);
        }

        std::ostringstream content;
        content << file.rdbuf();
        return content.str();
    }

    std::string CodeGenerator::GetDefaultTemplate(const std::string& templateName)
    {
        if (templateName == "Component.h.template")
        {
            return DEFAULT_COMPONENT_TEMPLATE;
        }
        else if (templateName == "System.h.template")
        {
            return DEFAULT_SYSTEM_H_TEMPLATE;
        }
        else if (templateName == "System.cpp.template")
        {
            return DEFAULT_SYSTEM_CPP_TEMPLATE;
        }
        else if (templateName == "Event.h.template")
        {
            return DEFAULT_EVENT_TEMPLATE;
        }

        return "";
    }

    std::string CodeGenerator::ApplyTemplate(
        const std::string& templateContent,
        const std::map<std::string, std::string>& variables)
    {
        std::string result = templateContent;

        for (const auto& [key, value] : variables)
        {
            std::string placeholder = "${" + key + "}";
            size_t pos = 0;

            while ((pos = result.find(placeholder, pos)) != std::string::npos)
            {
                result.replace(pos, placeholder.length(), value);
                pos += value.length();
            }
        }

        return result;
    }

    std::string CodeGenerator::NormalizeType(const std::string& type)
    {
        // Map common type aliases to C++ types
        static const std::map<std::string, std::string> typeMap = {
            {"int", "int"},
            {"int32", "int32_t"},
            {"int64", "int64_t"},
            {"uint", "unsigned int"},
            {"uint32", "uint32_t"},
            {"uint64", "uint64_t"},
            {"float", "float"},
            {"double", "double"},
            {"bool", "bool"},
            {"string", "std::string"},
            {"str", "std::string"},
            {"vec2", "Vector2"},
            {"vec3", "Vector3"},
            {"vec4", "Vector4"},
            {"vector2", "Vector2"},
            {"vector3", "Vector3"},
            {"vector4", "Vector4"},
            {"entity", "EntityID"},
            {"entityid", "EntityID"},
        };

        std::string lowerType = type;
        std::transform(lowerType.begin(), lowerType.end(), lowerType.begin(),
            [](unsigned char c) { return std::tolower(c); });

        auto it = typeMap.find(lowerType);
        if (it != typeMap.end())
        {
            return it->second;
        }

        // Return original type if no mapping found
        return type;
    }

    std::string CodeGenerator::GenerateMemberDeclarations(
        const std::vector<MemberDefinition>& members,
        const std::string& indent)
    {
        std::ostringstream declarations;

        for (size_t i = 0; i < members.size(); ++i)
        {
            const auto& member = members[i];
            std::string cppType = NormalizeType(member.Type);

            declarations << indent << cppType << " " << member.Name;

            // Add default initialization
            if (cppType == "int" || cppType == "int32_t" || cppType == "int64_t" ||
                cppType == "unsigned int" || cppType == "uint32_t" || cppType == "uint64_t")
            {
                declarations << " = 0";
            }
            else if (cppType == "float")
            {
                declarations << " = 0.0f";
            }
            else if (cppType == "double")
            {
                declarations << " = 0.0";
            }
            else if (cppType == "bool")
            {
                declarations << " = false";
            }
            else if (cppType == "EntityID")
            {
                declarations << " = INVALID_ENTITY";
            }

            declarations << ";";

            if (i < members.size() - 1)
            {
                declarations << "\n";
            }
        }

        return declarations.str();
    }

    std::string CodeGenerator::GenerateConstructorParams(
        const std::vector<MemberDefinition>& members)
    {
        std::ostringstream params;

        for (size_t i = 0; i < members.size(); ++i)
        {
            const auto& member = members[i];
            std::string cppType = NormalizeType(member.Type);

            // Use const reference for complex types
            if (cppType == "std::string" || cppType == "Vector2" ||
                cppType == "Vector3" || cppType == "Vector4")
            {
                params << "const " << cppType << "& " << member.Name << "_";
            }
            else
            {
                params << cppType << " " << member.Name << "_";
            }

            if (i < members.size() - 1)
            {
                params << ", ";
            }
        }

        return params.str();
    }

    std::string CodeGenerator::GenerateInitializerList(
        const std::vector<MemberDefinition>& members)
    {
        std::ostringstream initList;

        for (size_t i = 0; i < members.size(); ++i)
        {
            const auto& member = members[i];

            if (i == 0)
            {
                initList << ": ";
            }
            else
            {
                initList << ", ";
            }

            initList << member.Name << "(" << member.Name << "_)";
        }

        return initList.str();
    }

    bool CodeGenerator::WriteFile(const std::string& filePath, const std::string& content)
    {
        // Ensure parent directory exists
        std::filesystem::path path(filePath);
        if (!EnsureDirectoryExists(path.parent_path().string()))
        {
            return false;
        }

        std::ofstream file(filePath);
        if (!file.is_open())
        {
            m_LastError = "Failed to open file for writing: " + filePath;
            return false;
        }

        file << content;
        file.close();

        m_GeneratedFiles.push_back(filePath);
        return true;
    }

    bool CodeGenerator::EnsureDirectoryExists(const std::string& path)
    {
        try
        {
            if (!std::filesystem::exists(path))
            {
                std::filesystem::create_directories(path);
            }
            return true;
        }
        catch (const std::filesystem::filesystem_error& e)
        {
            m_LastError = "Failed to create directory: " + std::string(e.what());
            return false;
        }
    }

    bool CodeGenerator::GenerateComponent(
        const std::string& name,
        const std::vector<MemberDefinition>& members,
        const std::string& outputPath)
    {
        m_GeneratedFiles.clear();
        m_LastError.clear();

        // Load template
        std::string templateContent = LoadTemplate("Component.h.template");
        if (templateContent.empty())
        {
            m_LastError = "Failed to load Component.h.template";
            return false;
        }

        // Prepare variables
        std::map<std::string, std::string> variables;
        variables["NAME"] = name;

        std::string fileName = name + "Component.h";
        std::filesystem::path filePath = std::filesystem::path(outputPath) / fileName;
        variables["FILE_PATH"] = filePath.string();

        variables["MEMBERS"] = GenerateMemberDeclarations(members);

        // Generate constructor if there are members
        if (!members.empty())
        {
            std::ostringstream constructor;
            constructor << "        " << name << "Component(" << GenerateConstructorParams(members) << ")\n";
            constructor << "            " << GenerateInitializerList(members) << " {}";
            variables["CONSTRUCTOR"] = constructor.str();
        }
        else
        {
            variables["CONSTRUCTOR"] = "";
        }

        // Apply template
        std::string content = ApplyTemplate(templateContent, variables);

        // Write file
        if (!WriteFile(filePath.string(), content))
        {
            return false;
        }

        return true;
    }

    bool CodeGenerator::GenerateSystem(
        const std::string& name,
        const std::string& outputPath)
    {
        m_GeneratedFiles.clear();
        m_LastError.clear();

        // Generate header file
        std::string headerTemplate = LoadTemplate("System.h.template");
        if (headerTemplate.empty())
        {
            m_LastError = "Failed to load System.h.template";
            return false;
        }

        std::map<std::string, std::string> variables;
        variables["NAME"] = name;

        std::string headerFileName = name + "System.h";
        std::filesystem::path headerPath = std::filesystem::path(outputPath) / headerFileName;
        variables["FILE_PATH"] = headerPath.string();

        std::string headerContent = ApplyTemplate(headerTemplate, variables);

        if (!WriteFile(headerPath.string(), headerContent))
        {
            return false;
        }

        // Generate source file
        std::string sourceTemplate = LoadTemplate("System.cpp.template");
        if (sourceTemplate.empty())
        {
            m_LastError = "Failed to load System.cpp.template";
            return false;
        }

        std::string sourceFileName = name + "System.cpp";
        std::filesystem::path sourcePath = std::filesystem::path(outputPath) / sourceFileName;
        variables["FILE_PATH"] = sourcePath.string();

        std::string sourceContent = ApplyTemplate(sourceTemplate, variables);

        if (!WriteFile(sourcePath.string(), sourceContent))
        {
            return false;
        }

        return true;
    }

    bool CodeGenerator::GenerateEvent(
        const std::string& name,
        const std::vector<MemberDefinition>& members,
        const std::string& outputPath)
    {
        m_GeneratedFiles.clear();
        m_LastError.clear();

        // Load template
        std::string templateContent = LoadTemplate("Event.h.template");
        if (templateContent.empty())
        {
            m_LastError = "Failed to load Event.h.template";
            return false;
        }

        // Prepare variables
        std::map<std::string, std::string> variables;
        variables["NAME"] = name;

        std::string fileName = name + "Event.h";
        std::filesystem::path filePath = std::filesystem::path(outputPath) / fileName;
        variables["FILE_PATH"] = filePath.string();

        variables["MEMBERS"] = GenerateMemberDeclarations(members);

        // Generate constructor if there are members
        if (!members.empty())
        {
            std::ostringstream constructor;
            constructor << "        " << name << "Event(" << GenerateConstructorParams(members) << ")\n";
            constructor << "            " << GenerateInitializerList(members) << " {}";
            variables["CONSTRUCTOR"] = constructor.str();
        }
        else
        {
            variables["CONSTRUCTOR"] = "";
        }

        // Apply template
        std::string content = ApplyTemplate(templateContent, variables);

        // Write file
        if (!WriteFile(filePath.string(), content))
        {
            return false;
        }

        return true;
    }

} // namespace gendev
